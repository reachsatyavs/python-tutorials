# Terraform

Infrastructure-as-code for a **hub-and-spoke GCP foundation** driven by **JSON configuration files**.  
This repository provisions bootstrap projects, hub networking, spoke (stage/prod/alpha) networking, VPN, and datastore projects (e.g., Valkey) using reusable Terraform modules.

---

## JSON Configuration Overview

The entire Terraform workflow is **JSON-driven**.  
The JSON configuration files are **exported from existing GCP Hub and Spoke projects** using a standardized set of `gcloud` commands.  
These exported files capture all relevant network components — such as VPCs, subnets, routers, NATs, firewalls, DNS zones, VPNs, and other shared services — in a portable format.

Once generated, Terraform simply **reads these JSON files** and **recreates the same infrastructure** in a new project or environment.  
This makes it easy to clone or replicate an existing network topology (e.g., Hub/Stage/Prod) while keeping configurations consistent and version-controlled.

**Summary:**
- JSON files are generated by scanning an existing project’s network stack with `gcloud compute ... --format=json`.
- Terraform dynamically parses those JSONs and iterates through the data to invoke reusable modules.
- The same templates can recreate or update environments (Hub/Stage/Prod/Alpha) with minimal manual effort.

---

## Highlights

- **JSON-driven:** Terraform code reads configuration details directly from JSON files under `config/`.
- **Dynamic iteration:** The code iterates through JSON data and invokes relevant modules automatically where required.
- **Modular design:** Common modules under `modules/` are reused across environments.
- **Hub & Spoke architecture:** Centralized hub VPC with multiple spoke VPCs for different environments.
- **Clear separation of concerns:** bootstrap → hub → spokes → vpn → datastore.


---

## Repository Layout
```
cf-terraform/
├── README.md                             # Project overview, setup, and usage guide
│
├── config/                               # 🔧 Central configuration layer
│   ├── common.tfvars                     # Global variables (org ID, billing, folders, impersonation, etc.)
│   ├── hub_config.json                   # Hub configuration (shared VPC, subnets, NAT, DNS, PSA/PSC)
│   │
│   ├── stage/                            # Stage environment configs
│   │   ├── network.json                  # Stage spoke network (VPC, subnets, firewall, NAT)
│   │   ├── vpn_config.json               # Stage VPN tunnels, gateways, PSKs
│   │   └── datastore.json                # Stage Valkey/Memorystore configuration
│   │
│   ├── prod/                             # Production environment configs
│   └── alpha/                            # Alpha/test environment configs
│
├── common-tf/                            # Common Terraform logic shared by all environments
│   ├── main.tf                           # Reads JSON configs, iterates, and invokes modules dynamically
│   ├── variables.tf                      # Common variable definitions
│   ├── outputs.tf                        # Shared outputs (network links, DNS details, etc.)
│   └── providers.tf                      # Google provider + remote backend setup
│
├── env/                                  # Environment-specific Terraform execution folders
│   ├── bootstrap_folder_project/         # Bootstrap: creates GCP projects under existing folders
│   │   ├── backend.tf                    # file tells Terraform where to store the state file
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── outputs.tf
│   │
│   ├── hub/                              # Hub environment deployment (shared VPC, NAT, DNS)
│   │   ├── backend.tf                    # file tells Terraform where to store the state file
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── outputs.tf
│   │
│   ├── stage/                            # Stage environment deployment
│   │   ├── network/                      # Stage spoke networking (reads from config/stage/network.json)
│   │   │   ├── main.tf
│   │   │   ├── variables.tf
│   │   │   └── outputs.tf
│   │   │   └── backend.tf                # file tells Terraform where to store the state file
│   │   │
│   │   ├── vpn/                          # Stage VPN setup (reads from config/stage/vpn_config.json)
│   │   │   ├── main.tf
│   │   │   ├── variables.tf
│   │   │   └── outputs.tf
│   │   │   └── backend.tf                # file tells Terraform where to store the state file
│   │   │
│   │   └── datastore/                    # Stage datastore (reads from config/stage/datastore.json)
│   │       ├── main.tf
│   │       ├── variables.tf
│   │       └── outputs.tf
│   │   │   └── backend.tf                # file tells Terraform where to store the state file
│   │
│   ├── prod/                             # Prod deployment (reads from config/prod/)
│   │   ├── network/
│   │   ├── vpn/
│   │   └── datastore/
│   │
│   └── alpha/                            # Alpha deployment (reads from config/alpha/)
│       ├── network/
│       ├── vpn/
│       └── datastore/
│
├── modules/                              # Reusable Terraform modules
│   ├── network/                          # Creates VPCs, routing mode, MTU
│   ├── subnet/                           # Creates subnets + secondary ranges
│   ├── firewall/                         # Firewall ingress/egress rules
│   ├── router/                           # Cloud Routers (BGP ASN)
│   ├── nat/                              # Cloud NAT configuration per router
│   ├── dns_zone/                         # DNS zones (Public, Private, Forwarding, Peering)
│   ├── vpn/                              # HA/Classic VPN gateways and tunnels
└────── datastore                         # Valkey / Memorystore provisioning
│
├── scripts/                              # Reusable Terraform modules
│   ├── bootstrap_env.sh/                 # Creates bootstrap project, Terraform service account and necessary IAM bindings and permissions
```

##  Environments & Flow

Terraform code **reads configuration details from JSON files** under the `config/` directory.  
It then **iterates through the JSON data** and dynamically **invokes appropriate modules** to provision each infrastructure component.

### Workflow overview

1. **Bootstrap** (`env/bootstrap_folder_project`)  
   Creates GCP projects under existing folders, linked with billing and IAM setup.

2. **Hub** (`env/hub`)  
   Builds the **hub networking layer** — shared VPC, core subnets, routes, NAT, and centralized DNS zones (public, private, forwarding, or peering).

3. **Spokes** (`env/<stage|prod|alpha>/network`)  
   Creates **spoke** VPCs for each environment: subnets, firewall rules, routers, and NATs as per the configuration JSON.

4. **VPN** (`env/<stage|prod|alpha>/vpn`)  
   Sets up **HA/Classic VPNs**, tunnels, and peer connections to on-prem or other cloud environments. Supports dynamic PSK input via environment variable.

5. **Datastore** (`env/<stage|prod|alpha>/datastore`)  
   Provisions datastore services such as **Valkey/Memorystore** in corresponding projects.

---

##  Configuration

Shared variables and environment-specific inputs are placed in the `config/` directory.

Typical configuration includes:
- Project IDs and folder IDs  
- VPC names, regions, subnets, and secondary IP ranges  
- Firewall rule definitions  
- Router and NAT configurations  
- DNS managed zones (with `zone_type`: PUBLIC / PRIVATE / FORWARDING / PEERING)  
- VPN gateway and tunnel definitions  
- Datastore (Valkey/Memorystore) configuration details  

---

## 🧱 Modules (High-Level Overview)

| Module | Description |
|---------|-------------|
| **network** | Creates VPCs, routing mode, and MTU settings. |
| **subnet** | Creates regional subnets, secondary IP ranges, and enables Private Google Access. |
| **firewall** | Defines ingress and egress rules with priorities and network tags. |
| **router** | Creates Cloud Routers and configures BGP ASN for dynamic routing. |
| **nat** | Configures Cloud NAT per router, handling IP allocation and ports per VM. |
| **dns_zone** | Manages Cloud DNS zones — **Public**, **Private**, **Forwarding**, and **Peering** — based on JSON configuration. |
| **vpn** | Creates HA/Classic VPN gateways, tunnels, peer connections, and routing. |
| **datastore** | Provisions **Valkey / Memorystore** instances and applies required IAM bindings. |

---

## 📜 Command Summary

Each environment directory (`env/<hub|stage|prod|alpha>/...`) contains its own Terraform stack.  
The Terraform code **reads configuration from JSON**, **iterates through the data**, and **invokes the appropriate modules dynamically** to build all necessary infrastructure components.

Typical command flow per environment:


##  Usage

Run Terraform commands from the respective environment folders as shown below.

### 1️⃣ Bootstrap Projects
```bash
cd env/bootstrap_folder_project
terraform init
terraform apply -var-file=../../config/common.tfvars
```
2️⃣ Hub Network
```
cd env/hub
terraform init
terraform plan -var-file=../../config/common.tfvars
```
3️⃣ Spoke Network
```
cd env/stage/network
terraform init
terraform plan -var-file=../../../config/common.tfvars
```
4️⃣ Spoke VPN
```
cd env/stage/vpn
export TF_VAR_psk_by_spoke='{"spoke1":"passwordString="}'
terraform init
terraform plan
```
5️⃣ Stage Datastore
```
cd env/stage/datastore
terraform init
terraform plan
```

---
## ⚙️ Bootstrap Environment Setup (`bootstrap_env.sh`)

Before running any Terraform code, you must bootstrap a **GCP environment** that hosts:
- The **remote state bucket** (for Terraform state storage)
- The **Terraform service account** (used to impersonate and create infrastructure)
- The **necessary IAM bindings and permissions**

The script [`bootstrap_env.sh`](env/bootstrap_folder_project/bootstrap_env.sh) automates this setup.  
It ensures the foundational GCP resources and permissions exist so Terraform can run securely across multiple environments.

### 🔧 What the script does

1. **Validates or creates** a dedicated **bootstrap project** (if it doesn’t already exist).
2. **Links billing** to the project if a billing account is provided.
3. **Creates a versioned GCS bucket** (default: `tf-state-<project>`) to store Terraform state remotely.
4. **Creates a service account** (default: `terraform-admin@<project>.iam.gserviceaccount.com`)  
   which Terraform will impersonate when applying infrastructure changes.
5. **Grants IAM permissions**:
   - `roles/storage.objectAdmin` on the state bucket  
   - `roles/iam.serviceAccountTokenCreator` for the human user (to impersonate the SA)
   - `roles/resourcemanager.projectCreator` on an **Org** or **Folder** (to allow project creation)
   - `roles/billing.user` on the billing account (if provided)
6. **Prints a ready-to-use `backend.tf` template** referencing the created bucket and service account.

### 🪄 Example Usage

```bash
.scripts/bootstrap_env.sh \
  --bootstrap-project prj-infra-bootstrap \
  --billing 000000-000000-000000 \
  --org 123456789012 \
  --bucket tf-state--bucket \
  --location asia-south1123 \
  --create-bootstrap-project
```
---

##  Bootstrap & Authentication Setup (Before Running Terraform)

Before executing any Terraform commands, ensure your local environment is **clean** and properly configured for **service account impersonation**.  
Terraform in this repository runs **without downloading keys**, using **GCP service account impersonation** for security and compliance.

###  Step 1: Clean up any stale or cached credentials

```bash
unset GOOGLE_CLOUD_QUOTA_PROJECT
unset GOOGLE_IMPERSONATE_SERVICE_ACCOUNT
unset GOOGLE_PROJECT
unset GOOGLE_APPLICATION_CREDENTIALS
unset GOOGLE_OAUTH_ACCESS_TOKEN
unset CLOUDSDK_CORE_PROJECT

gcloud config unset auth/impersonate_service_account || true
gcloud auth revoke --all -q || true
gcloud auth application-default revoke -q || true
gcloud config unset project
rm -f ~/.config/gcloud/application_default_credentials.json

gcloud config configurations create clean --no-activate || true
gcloud config configurations activate clean

gcloud auth list
gcloud config list
```
---

### Step 2: Set impersonation environment variables

#### Example: Curefit Environment
```bash
export GOOGLE_IMPERSONATE_SERVICE_ACCOUNT=terraform-admin@terraform-bootstrap-prj-cf.iam.gserviceaccount.com
export NEW_PROJECT_ID=terraform-bootstrap-prj-cf
export GOOGLE_CLOUD_QUOTA_PROJECT=$NEW_PROJECT_ID
export CALLER=econzsupport@curefit.co
export SA_EMAIL=$GOOGLE_IMPERSONATE_SERVICE_ACCOUNT
```

---

### Step 3: Authenticate your user account and configure impersonation

```bash
gcloud auth login --account=$CALLER
gcloud auth application-default login --account=$CALLER
gcloud config set project $NEW_PROJECT_ID
gcloud config set auth/impersonate_service_account "$GOOGLE_IMPERSONATE_SERVICE_ACCOUNT"
```

---

### Step 4: Verify impersonation works

```bash
gcloud auth print-access-token --impersonate-service-account="$GOOGLE_IMPERSONATE_SERVICE_ACCOUNT" >/dev/null   && echo "✅ Impersonation OK" || echo "❌ Impersonation FAIL"
TF_LOG=DEBUG terraform init -reconfigure
```

---

###  Summary

| Step | Purpose |
|------|----------|
| **1. Clean Environment** | Removes residual gcloud state and cached credentials. |
| **2. Export Variables** | Sets your project, caller, and impersonated service account context. |
| **3. Login & Configure** | Authenticates your user and enables impersonation for Terraform. |
| **4. Verify** | Confirms impersonation setup before Terraform runs. |

